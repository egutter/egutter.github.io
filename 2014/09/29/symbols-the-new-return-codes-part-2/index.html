<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no"/>
  <title>Symbols: the new return codes? (Pt. 2)</title>
  <link href="https://egutter.github.io/prueba-blog/css/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"/>
  <link href="https://egutter.github.io/prueba-blog/css/style.css" type="text/css" rel="stylesheet" media="screen,projection"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/styles/default.min.css">
  <style type="text/css">
  
    footer.page-footer{background-image: url(https://egutter.github.io/prueba-blog/images/default.png);}
  
  </style>
</head>
<body>
  <ul id="slide-out" class="side-nav">
    <li><a href="https://egutter.github.io/prueba-blog"><i class="mdi-action-home left"></i>Home<i class="mdi-hardware-keyboard-arrow-right right"></i></a></li>
    <li><a href="https://egutter.github.io/prueba-blog/categories"><i class="mdi-action-perm-media left"></i>Categories<i class="mdi-hardware-keyboard-arrow-right right"></i></a></li>
    <li><a href="https://egutter.github.io/prueba-blog/tags"><i class="mdi-action-loyalty left"></i>Tags<i class="mdi-hardware-keyboard-arrow-right right"></i></a></li>
  </ul>
  <div id="index-banner" class="parallax-container">
  <a data-activates="slide-out" class="btn-floating button-collapse" style="top: 5px; left: 5px;"><i class="mdi-navigation-menu"></i></a>
    <div class="section no-pad-bot">
      <div class="container">
        
        <h1 class="header center teal-text text-lighten-2">10 Pines Blog</h1>
        <div class="row center">
          <h5 class="header col s12 light"></h5>
        </div>
        <div class="row center">
        
        
        
          <a href="https://www.facebook.com/10Pines"><img src="https://egutter.github.io/prueba-blog/images/facebook-dreamstale25.png"></a>
        
        
        
        
          <a href="https://www.linkedin.com/in/10Pines"><img src="https://egutter.github.io/prueba-blog/images/linkedin-dreamstale45.png"></a>
        
          <a href="https://egutter.github.io/prueba-blog/index.xml"><img src="https://egutter.github.io/prueba-blog/images/feed-dreamstale27.png"></a>
        </div>
      </div>
    </div>
    <div class="parallax">
    
      <img src="https://egutter.github.io/prueba-blog//images/10pines-background.jpg">
    
    </div>
  </div>



<div class="container">
  <div class="section">

    <div class="row">
      <div class="col s12">
        <div class="card-panel">
          <h4>Symbols: the new return codes? (Pt. 2)</h4>
          <p>
          
            
              <a href="https://egutter.github.io/prueba-blog/categories/ruby/">ruby</a>
            
              <a href="https://egutter.github.io/prueba-blog/categories/nil/">nil</a>
            
              <a href="https://egutter.github.io/prueba-blog/categories/closures/">closures</a>
            
              <a href="https://egutter.github.io/prueba-blog/categories/symbols/">symbols</a>
            
              <a href="https://egutter.github.io/prueba-blog/categories/exceptions/">exceptions</a>
            
           
          </p>
          <p>

<h2 id="flow-control-with-exceptions-and-closures">Flow control with exceptions and closures</h2>

<p>In <a href="http://blog.10pines.com/2014/09/23/symbols-the-new-return-codes/" title="Symbols, the new return codes?">this previous post</a> we&rsquo;ve considered the benefits and inconveniences of using nil and symbols as return values in a method.
Now we’ll evaluate the possibility of throwing an exception, and yet another alternative: using a closure.</p>

<p>So, before jumping in, let&rsquo;s bring to memory the example with which we were working.</p>

<pre><code class="language-ruby">
class User

  def find_by_id(id)
    # retrieve something from the persistence layer
    user_record = persistence_layer.find_record_by_id(id)

    # build user from record
    parse user_record
  end

end

</code></pre>

<p>This method should find an instance of a class by it&rsquo;s id. If none is found, then <code>find_record_by_id</code> returns nil.</p>

<h2 id="throwing-an-exception">Throwing an exception</h2>

<p>If we were to work with exceptions in this scenario, the code for our method would look something like this:</p>

<pre><code class="language-ruby">
class User
 
  def find_by_id(id)
    # retrieve something from the persistence layer
    user_record = persistence_layer.find_record_by_id(id)
    
    raise ObjectNotFoundError.new(id) if user_record.nil? 
    
    # build user from record
    parse user_record
  end
 
end

</code></pre>

<p>And this is how we would use it:</p>

<pre><code class="language-ruby">
begin
  user = User.find_by_id(1)
rescue ObjectNotFoundError =&gt; e
  # do something to handle user not found
end
 
# do something with the user

</code></pre>

<p>This solution is usually more acceptable than the ones we have previously considered.
It allows us to send a meaningful message to those who are expecting a non-null object, telling them that it was not found, and it also provides a way to choose the scope in which we want to handle the object-not-found situation.</p>

<p>Plus, we automatically have context: and almost as much as we want to! Besides from getting the full stack trace printed out to our noses, exceptions provide us a way to subclass and specify errors, to add descriptions, and even supply the id of the user that we were looking for.<sup class="footnote-ref" id="fnref:1"><a rel="footnote" href="#fn:1">1</a></sup></p>

<p>And if we don&rsquo;t want to catch them, it&rsquo;s OK too. We can let them reach our global error handler, and forget about it.</p>

<p>This is fine if we don’t mind using a try/catch block each time we send the message, or any message that we know collaborates with this one.
But it comes with the burden of needing to know what, and if, this message throws an exception. Something that without meta-programming, we lack in dynamic typed programming languages.</p>

<p>Another downside is that we would be using exceptions as flow-control structures, when instead we should be using them for what they are really meant to do: handle exceptional cases.<sup class="footnote-ref" id="fnref:2"><a rel="footnote" href="#fn:2">2</a></sup>
If having an unauthenticated user is part of our business logic, then not finding him in our database should be something quite normal.</p>

<p>So, what can we do if we don’t want to sprinkle our code with try/catch blocks, nor remember that we have to?
What if we want to have an object that represents the decisions we make in the flow of the program?</p>

<p>Then, we arrive to our final destination: closures!</p>

<h2 id="using-closures">Using Closures</h2>

<p>What benefit do closures provide for us, and why?
Let’s see how we would use them in our method:</p>

<pre><code class="language-ruby">
class User
 
  def find_by_id(id, &amp;user_not_found_block)
    # retrieve something from the persistence layer
    user_record = persistence_layer.find_record_by_id(id)
    
     # do something to handle user not found
    return user_not_found_block.call if user_record.nil? 
    
    # build user from record
    parse user_record
  end
 
end

</code></pre>

<p>So, what has changed?</p>

<p>First of all, let’s pay attention to the signature. This signature by itself will remind us that each time we send this message, we should provide a way to handle an inexistent result.</p>

<pre><code class="language-ruby">
user = User.find_by_id(1) { raise &quot;Hey! I couldn't find an user with id: #{1}&quot; }
 
# do something with the user

</code></pre>

<p>Or even better!</p>

<pre><code class="language-ruby">
user = User.find_by_id(1) { AnonymousUser.new }

</code></pre>

<p>This way, we could return an object that is polymorphic with what we are expecting (a <code>User</code>), as opossed to the nil/symbols scenario.<sup class="footnote-ref" id="fnref:3"><a rel="footnote" href="#fn:3">3</a></sup></p>

<p>And of course, if we don’t want to provide a block each time we use this particular method, the class of the object itself could define a default way of handling this, which could be, for example, throwing an exception:</p>

<pre><code class="language-ruby">
class User


  def find_by_id(id, user_not_found_block=method(:default_not_found_block))
    # retrieve something from the persistence layer
    user_record = persistence_layer.find_record_by_id(id)
    
     # do something to handle user not found
    return user_not_found_block.call(id) if user_record.nil? 
    
    # build user from record
    parse user_record
  end

  def default_not_found_block(id)
    raise &quot;Hey! I couldn't find an user with id: #{id}&quot; 
  end
 
end

</code></pre>

<p>The second advantage of using closures, besides the friendly reminder of the object-not-found possibility, is that <strong>it eliminates the need of checking for nil each time we send the message</strong> <code>find_by_id</code>. This is what allows us to encapsulate the <code>if</code>, and get rid of the repeated pattern.</p>

<p>In this matter, it is similar to the “throw an exception” solution, but with the benefit that at the same time it solves the exceptional case from within the method, it does so using a block provided from an outer context. And apart from eliminating repeated code, closures are flexible enough to allow us to recreate any of the situations we&rsquo;ve reviewed so far (which tells us they are a good generalization).</p>

<p>The third advantage, also similar to the exceptions solution, is that because closures bind to the context in which they are instantiated, there is no context loss. So you still have access to the execution context (e.g. you could make use of the user id, if you needed to).</p>

<p>The fourth advantage is that using closures you can create your own flow control sintax.<sup class="footnote-ref" id="fnref:4"><a rel="footnote" href="#fn:4">4</a></sup></p>

<p>And finally, in systems where performance is critical, closures tend to behave better than exceptions.<sup class="footnote-ref" id="fnref:5"><a rel="footnote" href="#fn:5">5</a></sup></p>

<p>So, where is the trick? What&rsquo;s the downside?
Surprisingly enough, sometimes the only reason for closures to be unpopular is the mental effort that one must do before being able to incorporate them into the way of thinking. But the truth is we have been using this since Smalltalk&rsquo;s “detect”!</p>

<h2 id="to-summarize">To summarize</h2>

<p>Nil</p>

<pre><code>+ Does not answer messages

- Will explode only if (and when) we try to use it
- Hard to debug
- Repeated code
</code></pre>

<p>Symbols</p>

<pre><code>+ Descriptive

- Be careful when you write them!
- Annoying conventions
- They answer messages, they can be evasive
</code></pre>

<p>Exceptions</p>

<pre><code>+ Descriptive
+ We can choose the solution's scope
+ Automatic context information
+ We can choose not to handle them

- Try/catch blocks everywhere
- Need to remember which methods throw them
- Normal flow handled by exceptions
</code></pre>

<p>Closures</p>

<pre><code>+ Friendly reminder
+ Default way to handle error
+ Flexible
+ No context loss
+ You can create your own flow control sintax
+ Performant

- Mental effort?
</code></pre>
<div class="footnotes">

<hr />

<ol>
<li id="fn:1">more on writing exceptions in ruby <a href="https://www.youtube.com/watch?v=nlvCYJodigM&amp;list=PLMkq_h36PcLA4yY58tQgj5FAXRzMaZAaY" title="Implementando Excepciones con Ruby">here!</a>
 <a class="footnote-return" href="#fnref:1"><sup>[return]</sup></a></li>
<li id="fn:2">see <a href="http://c2.com/cgi/wiki?DontUseExceptionsForFlowControl" title="Don't use exceptions for flow control">Don&rsquo;t use exceptions for flow control</a>
 <a class="footnote-return" href="#fnref:2"><sup>[return]</sup></a></li>
<li id="fn:3">see <a href="http://www.cs.oberlin.edu/~jwalker/refs/woolf.ps" title="Null Object Pattern">Null Object Pattern</a>
 <a class="footnote-return" href="#fnref:3"><sup>[return]</sup></a></li>
<li id="fn:4">see <a href="http://library.readscheme.org/page1.html" title="The Original 'Lambda Papers' by Guy Steele and Gerald Sussman">Lambda: The Ultimate</a>
 <a class="footnote-return" href="#fnref:4"><sup>[return]</sup></a></li>
<li id="fn:5">more on exceptions performance in JRuby <a href="http://blog.10pines.com/2013/05/18/parallel-tests-on-travis/" title="Parallel Tests on Travis">here!</a>
 <a class="footnote-return" href="#fnref:5"><sup>[return]</sup></a></li>
</ol>
</div>
</p>
          <p>29 Sep 2014
            
          </p>
          
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col s3 m1">
      
        <a class="btn-floating btn-large waves-effect waves-light" href="https://egutter.github.io/prueba-blog/2014/10/14/mixins-or-traits/"><i class="mdi-navigation-arrow-back"></i></a>
      
      </div>
      <div class="col s6 m10 center">&nbsp</div>
      <div class="col s3 m1">
      
        <a class="btn-floating btn-large waves-effect waves-light" href="https://egutter.github.io/prueba-blog/2014/09/24/symbols-the-new-return-codes/"><i class="mdi-navigation-arrow-forward"></i></a>
      
      </div>
    </div>

  </div>
</div>

  <footer class="page-footer">
    <div class="footer-copyright">
      <div class="container">
      
      <div class="right">Design <a class="grey-text text-lighten-4" href="http://pdevty.github.io/blog/">pdevty</a></div>
      </div>
    </div>
  </footer>
  <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
  <script src="https://egutter.github.io/prueba-blog/js/materialize.min.js"></script>
  <script src="https://egutter.github.io/prueba-blog/js/init.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  

  </body>
</html>

