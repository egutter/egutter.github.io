
<!DOCTYPE html>
<html lang="en-us">

    <head>

        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />

        <meta property="og:title" content=" protocolo fix: aspectos básicos y utilización en java mediante la librería quickfix/j &middot;  10 Pines Blog" />
        <meta property="og:site_name" content="10 Pines Blog" />
        <meta property="og:url" content="https://egutter.github.io/2011/11/21/protocolo-fix-aspectos-basicos-y-utilizacion-en-java-mediante-la-librera-quickfixj/" />

    
        <meta property="og:type" content="article" />
        <meta property="og:article:published_time" content="2011-11-21T00:00:00Z" />
        

        <meta name="twitter:card" content="summary" />
        <meta name="twitter:site" content="@" />
        <meta name="twitter:creator" content="@" />
        <meta name="twitter:title" content="protocolo fix: aspectos básicos y utilización en java mediante la librería quickfix/j" />
        <meta name="twitter:description" content="" />
        <meta name="twitter:url" content="https://egutter.github.io/2011/11/21/protocolo-fix-aspectos-basicos-y-utilizacion-en-java-mediante-la-librera-quickfixj/" />
    

        <title> protocolo fix: aspectos básicos y utilización en java mediante la librería quickfix/j &middot;  10 Pines Blog</title>

    
        <meta name="description" content="" />
    

        <meta name="p:domain_verify" content="fc173d84e3a4de948ed4bda2908afd3e"/>
        <meta name="HandheldFriendly" content="True" />
        <meta name="MobileOptimized" content="320" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        
        

    
        <link href="https://egutter.github.ioindex.xml" rel="alternate" type="application/rss+xml" title="10 Pines Blog" />
    

    
        <link rel="canonical" href="https://egutter.github.io/2011/11/21/protocolo-fix-aspectos-basicos-y-utilizacion-en-java-mediante-la-librera-quickfixj/" />

    
    <script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "Article",
        "headline": "protocolo fix: aspectos básicos y utilización en java mediante la librería quickfix\/j",
        "author": {
            "@type": "Person",
            "name": "http://profiles.google.com/?rel=author"
        },
        "datePublished": "2011-11-21",
        "description": "",
        "wordCount":  2570 
    }

    </script>

    <script type="text/javascript">
    
    
      var disqus_shortname = '10pinesblog';
      var disqus_identifier = 'https:\/\/egutter.github.io\/2011\/11\/21\/protocolo-fix-aspectos-basicos-y-utilizacion-en-java-mediante-la-librera-quickfixj\/';
      var disqus_title = 'protocolo fix: aspectos básicos y utilización en java mediante la librería quickfix\/j';
      var disqus_url = 'https:\/\/egutter.github.io\/2011\/11\/21\/protocolo-fix-aspectos-basicos-y-utilizacion-en-java-mediante-la-librera-quickfixj\/';
    

    </script>
    

    <style>
@charset "UTF-8";article,header,img,main,nav,section{display:block}blockquote,p,pre,ul{margin:2em auto}#wrapper,pre{width:100%;box-sizing:border-box}#nav,#wrapper,code{position:relative}#nav,body{background:#fff}#menu,blockquote,pre code{background:0 0}#menu,#menu .menu-header,#menu .menu-list,#wrapper,.post-nav .post-nav-item .post-nav-teaser .post-nav-info,blockquote,pre{box-sizing:border-box}img{border:0;max-width:100%;height:auto;margin:2.5em auto}html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}code,pre{font-family:monospace,monospace;font-size:1em}@font-face{font-family:'Merriweather Sans';font-style:normal;font-weight:300;src:local("Merriweather Sans Light"),local("MerriweatherSans-Light"),url(//fonts.gstatic.com/s/merriweathersans/v5/6LmGj5dOJopQKEkt88GowY_zIojJi0m4a5Z6tRh6itY.woff) format("woff")}@font-face{font-family:'Merriweather Sans';font-style:normal;font-weight:400;src:local("Merriweather Sans Regular"),local("MerriweatherSans-Regular"),url(//fonts.gstatic.com/s/merriweathersans/v5/AKu1CjQ4qnV8MUltkAX3sL2aU247V0zTzydO4RoO9Ok.woff) format("woff")}@font-face{font-family:'Merriweather Sans';font-style:normal;font-weight:700;src:local("Merriweather Sans Bold"),local("MerriweatherSans-Bold"),url(//fonts.gstatic.com/s/merriweathersans/v5/6LmGj5dOJopQKEkt88GowQfd-b-I5PxxcmB4_-MNcqw.woff) format("woff")}@font-face{font-family:'Merriweather Sans';font-style:normal;font-weight:800;src:local("Merriweather Sans ExtraBold"),local("MerriweatherSans-ExtraBold"),url(//fonts.gstatic.com/s/merriweathersans/v5/6LmGj5dOJopQKEkt88GowWT7sFQ1Iz1BbpcuCPlgc9Q.woff) format("woff")}@font-face{font-family:'Merriweather Sans';font-style:italic;font-weight:300;src:local("Merriweather Sans Light Italic"),local("MerriweatherSans-LightItalic"),url(//fonts.gstatic.com/s/merriweathersans/v5/nAqt4hiqwq3tzCecpgPmVX9UU5BmOJGkLxUCVv5VXdc.woff) format("woff")}@font-face{font-family:'Merriweather Sans';font-style:italic;font-weight:400;src:local("Merriweather Sans Italic"),local("MerriweatherSans-Italic"),url(//fonts.gstatic.com/s/merriweathersans/v5/3Mz4hOHzs2npRMG3B1ascf0KIgDhPIHb_R-SWdtqte8.woff) format("woff")}@font-face{font-family:'Merriweather Sans';font-style:italic;font-weight:700;src:local("Merriweather Sans Bold Italic"),local("MerriweatherSans-BoldItalic"),url(//fonts.gstatic.com/s/merriweathersans/v5/nAqt4hiqwq3tzCecpgPmVYM8pfYvjMoOxygpzLVILAs.woff) format("woff")}@font-face{font-family:Inconsolata;font-style:normal;font-weight:400;src:local("Inconsolata"),url(//fonts.gstatic.com/s/inconsolata/v12/BjAYBlHtW3CJxDcjzrnZCIbN6UDyHWBl620a-IRfuBk.woff) format("woff")}@font-face{font-family:Inconsolata;font-style:normal;font-weight:700;src:local("Inconsolata Bold"),local("Inconsolata-Bold"),url(//fonts.gstatic.com/s/inconsolata/v12/AIed271kqQlcIRSOnQH0yTqR_3kx9_hJXbbyU8S6IN0.woff) format("woff")}@font-face{font-family:icons;src:url(/fonts/icons.eot?9273991);src:url(/fonts/icons.eot?9273991#iefix) format("embedded-opentype"),url(/fonts/icons.woff?9273991) format("woff"),url(/fonts/icons.ttf?9273991) format("truetype"),url(/fonts/icons.svg?9273991#icons) format("svg");font-weight:400;font-style:normal}[class^=icon-]:before{font-family:icons;font-style:normal;font-weight:400;speak:none;display:inline-block;text-decoration:inherit;width:1em;margin-right:.2em;text-align:center;font-variant:normal;text-transform:none;line-height:1em;margin-left:.2em;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.icon-arrow-left:before{content:'\e804'}.icon-arrow-right:before{content:'\e807'}.icon-rss:before{content:'\e808'}.icon-menu:before{content:'\e809'}body{margin:0;font:300 1em/1.5em 'Merriweather Sans',sans-serif;color:#595B66}blockquote,i{font-style:italic}code,pre{font-family:Inconsolata,monospace}a,blockquote,code,i{font-weight:400}::-moz-selection{color:#222;background:#D6EDFF;text-shadow:none}::-moz-selection,::selection{color:#222;background:#D6EDFF;text-shadow:none}a{background-color:transparent;color:inherit;text-decoration:none;transition:all ease-out .2s}.post-content a{border-bottom:2px solid #36D995}h1,h4{text-rendering:optimizeLegibility;color:#1F2026}h1{font-size:2em;line-height:1em;margin:2em 0 -.5em}h4{font-size:1.25em;line-height:1.2em;margin:2.4em 0 -.8em}ul{list-style:none;padding-left:3em}blockquote{padding:0 1em;border-left:.25em solid #D4D5D9;color:#595B66}blockquote *{margin:1em auto}blockquote :first-child{margin-top:0}blockquote :last-child{margin-bottom:0}i{color:#363740}code{display:inline-block;top:-1px;padding:3px 6px;margin:-1px 2px;font-size:.875em;line-height:1.143em;background:#E1E2E6;color:#000;border-radius:2px}pre{padding:1em;white-space:pre;overflow:auto;background:#9D9FA6;color:#fff}pre code{position:static;top:auto;font-size:1em;line-height:1.5em;white-space:-moz-pre-wrap;white-space:pre-wrap;vertical-align:inherit;border:none;padding:0}#menu .menu-header:before,.post .post-title:before{border-bottom:4px solid #36D995;content:''}.inner{max-width:48em;margin:0 auto;padding:0 1em}#wrapper{min-height:100vh;padding-bottom:6em;background:#F2F3F5}#push{-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0);-webkit-transform-style:preserve-3d;transform-style:preserve-3d;opacity:1}#nav{z-index:70;transition:all ease-out .4s;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0);-webkit-transform-style:preserve-3d;transform-style:preserve-3d;opacity:1}#nav:after{clear:both;content:'';display:table}#nav .nav-logo{float:left;height:2em;padding:1em;max-width:50%}#nav .nav-logo img{width:auto;max-width:none;height:2em;margin:0}#nav .nav-menu{float:right}#nav .nav-menu:after{clear:both;content:'';display:table}#nav .nav-menu a{display:block;width:1em;height:1em;line-height:1em;padding:1.5em;text-align:center;float:left;cursor:pointer}#nav .nav-menu a i:before{margin:auto}#menu{display:none;position:fixed;left:50%;top:5%;width:30em;height:90%;margin-left:-15em;padding:3em 0 0;overflow:hidden;transition:all ease-out .3s;-webkit-transform:translate3d(0,2em,0);transform:translate3d(0,2em,0);-webkit-transform-style:preserve-3d;transform-style:preserve-3d;opacity:0;z-index:100}@media only screen and (max-width:50em){#menu{width:90%;left:5%;margin-left:auto}}#menu .menu-header{position:absolute;left:0;top:0;width:100%;height:3.5em;padding:1em 1.5em .5em;margin-bottom:1em;line-height:2em;z-index:110;background:#fff}#menu .menu-header:before{position:absolute;left:-5%;bottom:-1em;width:110%;height:2em;background:#fff;box-shadow:0 .125em .125em rgba(0,0,0,.1);-webkit-transform:rotate(2.5deg);transform:rotate(2.5deg);transition:all ease-out .2s;z-index:115}#menu .menu-header:after{clear:both;content:'';display:table}#menu .menu-header .menu-label{position:relative;display:block;float:left;z-index:120}#menu .menu-header .menu-close{position:relative;display:block;float:right;width:2em;height:2em;padding:1em;margin:-1em -1.5em -1em 0;cursor:pointer;z-index:125}#menu .menu-header .menu-close:after,#menu .menu-header .menu-close:before{content:'';position:absolute;left:50%;top:50%;background:#9D9FA6;-webkit-transform:rotate(45deg);transform:rotate(45deg)}.overlay,.overlay:before{top:0;width:100%;height:100%}#menu .menu-header .menu-close:after{width:2px;height:1em;margin:-.5em 0 0 -1px}#menu .menu-header .menu-close:before{width:1em;height:2px;margin:-1px 0 0 -.5em}#menu .menu-list{position:relative;list-style:none;margin:0;padding:2em 0;height:100%;overflow-x:hidden;overflow-y:scroll;background:#fff}.overlay{position:fixed;left:0;z-index:80;display:none}.overlay:before{content:'';position:absolute;left:0;background:#1F2026;opacity:0;transition:all ease-out .3s;-webkit-transform-style:preserve-3d;transform-style:preserve-3d}.post{position:relative;z-index:20}.post .post-meta{display:block;font-size:.75em;line-height:1.334em;font-weight:400;margin-bottom:1.334em}.post .post-title{position:relative;color:#000;font-size:2em;line-height:1.375em;font-weight:800;text-indent:-1px;margin:.25em 0 .75em}.post .post-title:before{position:absolute;left:0;bottom:-.334em;width:1em;margin-bottom:-2px}.post .post-header{padding:4em 0 0;margin-bottom:3em}.post-footer .post-share a span{display:none}.post-nav .post-nav-item{position:fixed;top:50%;display:block;margin-top:-4em;overflow:hidden;border-radius:10em;transition:none}@media only screen and (max-width:70em){.post-nav .post-nav-item{position:absolute;top:auto;margin:auto;max-width:50%}}.post-nav .post-nav-item.post-nav-next{left:0;text-align:left}.post-nav .post-nav-item.post-nav-next .post-nav-icon{float:left}.post-nav .post-nav-item.post-nav-next .post-nav-icon i{left:-.05em}.post-nav .post-nav-item.post-nav-next .post-nav-info{padding-left:6em}.post-nav .post-nav-item.post-nav-prev{right:0;text-align:right}.post-nav .post-nav-item.post-nav-prev .post-nav-icon{float:right}.post-nav .post-nav-item.post-nav-prev .post-nav-icon i{right:-.05em}.post-nav .post-nav-item.post-nav-prev .post-nav-info{padding-right:6em}.post-nav .post-nav-item .post-nav-teaser{display:block;padding:1em;transition:all ease-out .2s;max-width:25em;overflow:visible}.post-nav .post-nav-item .post-nav-teaser:after{clear:both;content:'';display:table}.post-nav .post-nav-item .post-nav-teaser .post-nav-icon{display:block;width:5em;height:5em;line-height:5em;text-align:center;box-sizing:border-box;border-radius:10em;border:1px solid #36D995;box-shadow:0 0 0 0 transparent;transition:all ease-out .1s;background:#F2F3F5}.post-nav .post-nav-item .post-nav-teaser .post-nav-icon i{position:relative;font-size:2em}@media only screen and (max-width:30em){.post-nav .post-nav-item .post-nav-teaser .post-nav-icon{width:4em;height:4em;line-height:4em}.post-nav .post-nav-item .post-nav-teaser .post-nav-icon i{font-size:1.5em}}.post-nav .post-nav-item .post-nav-teaser .post-nav-icon i:before{margin:auto}.post-nav .post-nav-item .post-nav-teaser .post-nav-info{display:none;width:100%;transition:all ease-out .2s}.post-nav .post-nav-item .post-nav-teaser .post-nav-info .post-nav-title{display:block;max-height:1.25em;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;margin:1.25em 0 .25em;font-size:1em;line-height:1.25em;font-weight:700;color:#363740}.post-nav .post-nav-item .post-nav-teaser .post-nav-info .post-nav-excerpt{display:block;max-height:1.334em;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;margin:0;font-size:.75em;line-height:1.334em;font-weight:400;color:#9D9FA6}
</style>


    </head>
    <body class="home-template" style="display: none;">
      <section id="wrapper">
        <div id="ajax-container">
          <nav id="nav" class="nav">
            <div class="nav-logo">
              <a href="https://egutter.github.io">
      			  	
      			  	
      			  	<img src="https://egutter.github.io/images/10p-logo.png" alt="Logo"/>
      			  	
              </a>
			  	    
            </div>
            <div class="nav-menu">
              <a class="rss" href="">
                <i class="icon-rss"></i>
              </a>
                
                <a class="menu" data-action="toc" data-target="toc"><i class="icon-location"></i></a>
                
                
            </div>
          </nav>


<main class="content" role="main">
	<article class="post">
		<div class="inner">

			<div id="push">

  			<header class="post-header">
  				<span class="post-meta">
						<span class="post-date">21 Nov 2011</span> <span class="reading-time">| <span class="estimated-reading-time">13 min.</span> (<span class="word-count">2570</span> words)</span></span>
  				</span>
  				<div class="clear"></div>
  				<h1 class="post-title">protocolo fix: aspectos básicos y utilización en java mediante la librería quickfix/j</h1>
  			</header>

  			<section class="post-content">
  				

<h2 id="introducción">Introducción</h2>

<p>El protocolo **FIX ** (<em>Financial Information Exchange Protocol</em>) es un protocolo de mensajes para el comercio de instrumentos financieros. <strong>FIX</strong> se utiliza ampliamente para la comunicación automática entre los participantes del intercambio de instrumentos, y especifica como son los mensajes para crear ordenes de compra y venta y consultar cotizaciones de instrumento, entre otros. Este protocolo es el que hay que utilizar para comunicarnos con practicamente todos los mercados financieros de manera electrónica.</p>

<p>En este articulo, veremos los aspectos básicos del protocolo <strong>FIX</strong>, como utilizarlo mediante la librería de java <strong>QuickFIX/J</strong> mediante un ejemplo como cliente y servidor, y algunos aspectos poco obvios que hay que tener en cuenta al utilizarlo.</p>

<h2 id="diferentes-versiones-del-protocolo-fix">Diferentes versiones del protocolo FIX</h2>

<p>El protocolo tiene diferentes versiones, el mismo fue evolucionando a través de los años, agregando diferentes mensajes y campos para acomodar las funcionalidades requeridas por los interlocutores de todo el mundo. La versión del protocolo se divide en dos: la versión del protocolo de mensajes en si (por ejemplo, <strong>FIX 5.0 SP2</strong>), y la versión del protocolo de transporte de <strong>FIX</strong>, <strong>FIXT</strong> (por ejemplo, <strong>FIXT 1.1</strong>). Las versiones anteriores a la 5 no tenían esa division de protocolo de mensajes y protocolo de transporte, y se denotan únicamente por el número de version del protocolo.</p>

<p>El protocolo <strong>FIX</strong> soporta extensiones, agregando nuevos mensajes y campos dentro de mensajes existentes, definiendo nuevos códigos de mensaje y nuevos números de campos. Para esto, los interlocutores deben conocer y estar de acuerdo en estas extensiones. De todas maneras, el protocolo <strong>FIX</strong> tiene una gran cantidad de campos pensados para muchisimos casos de usos, ampliandose versión a versión, por lo que la necesidad de extender el protocolo debería en teoría ser muy baja. Tampoco es necesario implementar la totalidad de los mensajes y todos los códigos opcionales existentes, sino solo los que tengan sentido y sean utilizados por nuestros interlocutores.</p>

<h2 id="cómo-es-el-formato-fix">Cómo es el formato FIX</h2>

<p>El formato <strong>FIX</strong> es un formato textual, donde cada mensaje es una única linea de la forma:</p>

<p><code>NUMERO_DE_CAMPO=CONTENIDO[SEPARADOR]NUMERO_DE_CAMPO=CONTENIDO[SEPARADOR]....</code></p>

<p>El separador es el caracter unicode representado en Java y otros como <strong>&ldquo;\u0001&rdquo;</strong>. Los campos se identifican por su número, y el tipo de mensaje es un campo más dentro del mensaje (el campo 35), y el último campo es el campo 10 que es el checksum. El orden de los campos importa, y está especificado para cada mensaje <strong>FIX</strong>. Las estructuras repetitivas en <strong>FIX</strong> se llaman <strong>Repeating Group</strong> y se definen simplemente definiendo un campo cabecera del <strong>Repeating Group</strong> que indica la cantidad de elementos contenidos, y todos los elementos se diferencian entre sí detectando el primer campo de cada elemento, esto funciona precisamente porque importa el orden de los campos.</p>

<h2 id="quickfix-j">QuickFIX/J</h2>

<p><strong>FIX</strong> es un protocolo abierto y gratuito; es solo la especificación de los mensajes y de los campos de los mismos, y existen varias implementaciones de este protocolo. <strong>QuickFIX/J</strong> es una implementación gratuita y open source (con una licencia propia similar a <strong>BSD</strong>/<strong>MIT</strong>) para Java (es un port de <strong>QuickFIX</strong>, que está escrita en C++), que es muy fácil de utilizar para comunicarnos con cualquier participante, ya sea como cliente o servidor.</p>

<p><em>Nota: QuickFIX/J no implementa lógica de negocio alguna, es decir, no implementa ningún motor de cotizaciones, matcheo de ordenes de compra y venta, etc; lo que implementa es únicamente es el protocolo de comunicación.</em></p>

<h2 id="ejemplos-de-cliente-y-servidor-en-quickfix-j">Ejemplos de Cliente y Servidor en QuickFIX/J</h2>

<p>Vamos a hacer un cliente de ejemplo en <strong>QuickFIX/J</strong> versión 1.5.1. Este cliente se conectará a un servidor, y apenas se conecte enviará una orden de compra de un instrumento ficticio, el servidor responderá con otro mensaje, y cuando el cliente reciba la respuesta de la compra, seteará una variable, y observaremos la respuesta de esa variable. Con este ejemplo, si bien irreal, veremos como se utiliza <strong>QuickFIX/J</strong> como cliente y como servidor.</p>

<p>El primer paso es <a href="http://www.quickfixj.org/downloads/">bajar la librería</a>. Hay varios Jars, uno por cada versión del protocolo <strong>FIX</strong>, pero vamos a incluir simplemente el que tiene todo (&ldquo;all&rdquo;), en este caso voy a incluir la última versión: <strong>quickfixj-all-1.5.1.jar</strong>. También debemos bajar (o bien configurar via Maven) las dependencias especificadas <a href="http://www.quickfixj.org/quickfixj/usermanual/1.5.1/installation.html#dependencies">aquí</a>.</p>

<p>Incluida esta librería en nuestro proyecto, tenemos que implementar nuestro cliente, y para esto <strong>QuickFIX/J</strong> nos pide que implementemos la interfaz <code>quickfix.Application</code>. <strong>QuickFIX/J</strong> es un framework que trabaja con el concepto de <em>Inversión de Control</em>: en lugar de invocar los métodos de <strong>QuickFIX/J</strong> para loguearnos, ir recibiendo los mensajes, etc; nosotros tenemos que darle un objeto <code>Application</code> y <strong>QuickFIX/J</strong> invoca a los métodos de ese objeto con los eventos que vayan ocurriendo, en sus propios threads.</p>

<p>La interfaz <code>Application</code> define métodos para cada evento que ocurra durante la comunicación, por ejemplo <code>onLogon</code>, <code>onLogout</code>, <code>fromApp</code> (se recibió un mensaje de negocio), <code>fromAdmin</code> (se recibio un mensaje relativo a la sesión, como por ejemplo rechazo de un mensaje mal formado), entre otros. Nosotros, en vez de implementar <code>Application</code> directamente, vamos a heredar de <code>ApplicationAdapter</code> que es una clase abstracta que tiene definiciones vacías para todos estos métodos por default. Es la misma interfaz tanto para Cliente como para Servidor.</p>

<p>``` java ExampleClientApplication.java</p>

<p>package com.tenpines.ejemplofix;</p>

<p>import quickfix.ApplicationAdapter;
import quickfix.FieldNotFound;
import quickfix.Message;
import quickfix.Session;
import quickfix.SessionID;
import quickfix.SessionNotFound;
import quickfix.field.ExecType;
import quickfix.field.Password;
import quickfix.field.Username;
import quickfix.fix50.ExecutionReport;
import quickfix.fix50.NewOrderSingle;
import quickfix.fixt11.Logon;</p>

<p>public class ExampleClientApplication extends ApplicationAdapter {
  private boolean seEjecutoOrdenCorrectamente = false;
  private  boolean estaLogueado = false;</p>

<p>private final NewOrderSingle newOrder;
  private final String usuario;
  private final String password;</p>

<p>public ExampleClientApplication(NewOrderSingle newOrder, String usuario, String password) {
    this.newOrder = newOrder;
    this.usuario = usuario;
    this.password = password;
  }</p>

<p>@Override
  public  void onLogon(SessionID sessionId) {
    this.estaLogueado = true;
    try {
      Session.sendToTarget(this.newOrder, sessionId);
    } catch (SessionNotFound e) {
      throw new RuntimeException(e);
    }
  }</p>

<p>@Override
  public  void fromApp(Message message, SessionID sessionId) throws FieldNotFound {
    if (message instanceof ExecutionReport) {
      ExecutionReport executionReport = (ExecutionReport) message;
      if (esExecutionReportNew(executionReport)) {
        // Como el mensaje corresponde a una creacion de orden,
        // verifico que se refiera a la misma orden que acabo de enviar
        // comparando su ClOrdID.
        if (esClOrdIDCorrecto(executionReport)) {
          this.seEjecutoOrdenCorrectamente = true;
        }
      }
    }
  }</p>

<p>private  boolean esClOrdIDCorrecto(ExecutionReport executionReport) throws FieldNotFound {
    return executionReport.getClOrdID().getValue().equals(this.newOrder.getClOrdID().getValue());
  }</p>

<p>private  boolean esExecutionReportNew(ExecutionReport executionReport) throws FieldNotFound {
    return executionReport.getExecType().getValue() == ExecType.NEW;
  }</p>

<p>@Override
  public  void toAdmin(Message message, SessionID sessionId) {
    if (message instanceof Logon) {
      message.setField(new Username(usuario));
      message.setField(new Password(password));
    }
  }</p>

<p>public  boolean estaLogueado() {
    return estaLogueado;
  }</p>

<p>public  boolean seEjecutoOrdenCorrectamente() {
    return seEjecutoOrdenCorrectamente;
  }
}</p>

<pre><code>
Esta clase en su constructor recibirá el mensaje `NewOrderSingle` de creación de una orden, que el cliente deberá enviar al loguearse. En el método `onLogon`, el cual **QuickFIX/J** invoca luego de un logueo exitoso, realiza el envío del mensaje con el método estático `Session.sendToTarget`.

En el método `fromApp`, se reciben los mensajes de negocio, y lo que buscamos es un mensaje de `ExecutionReport`, que es el mensaje de **FIX** con el que se reportan los cambios de estado de una orden (cuando es creada, cuando es cancelada, a medida que se va ejecutando, cuando es completada, etc).

Si el campo `ClOrdID` (el cual representa el *id de orden del cliente*) del `ExecutionReport` coincide con el que mandamos en el `NewOrderSingle`, seteamos el flag de `seEjecutoOrdenCorrectamente`.

Finalmente en el método `toAdmin`, que se invoca inmediatamente antes de enviar un mensaje &quot;administrativo&quot; (es decir, un mensaje que no es de negocio), interceptamos el mensaje `Logon` (que se crea automáticamente) y le asignamos usuario y password (sí, esa es la forma estándar de definir el usuario y password de la conexión).

``` java ExampleServerApplication.java

package com.tenpines.ejemplofix;

import quickfix.ApplicationAdapter;
import quickfix.FieldNotFound;
import quickfix.IncorrectTagValue;
import quickfix.Message;
import quickfix.RejectLogon;
import quickfix.Session;
import quickfix.SessionID;
import quickfix.SessionNotFound;
import quickfix.UnsupportedMessageType;
import quickfix.field.ClOrdID;
import quickfix.field.CumQty;
import quickfix.field.ExecID;
import quickfix.field.ExecType;
import quickfix.field.LeavesQty;
import quickfix.field.OrdStatus;
import quickfix.field.OrderID;
import quickfix.fix50.ExecutionReport;
import quickfix.fix50.NewOrderSingle;
import quickfix.fixt11.Logon;

public class ExampleServerApplication extends ApplicationAdapter {

  @Override
  public  void fromAdmin(Message message, SessionID sessionId) throws FieldNotFound, RejectLogon {
    if (message instanceof Logon) {
      if (!usuarioYPasswordCorrectos((Logon) message)) {
        throw new RejectLogon();
      }
    }
  }

  private  boolean usuarioYPasswordCorrectos(Logon logon) throws FieldNotFound {
    return logon.getUsername().getValue().equals(&quot;usuario&quot;) 
        &amp;&amp; logon.getPassword().getValue().equals(&quot;password&quot;);
  }

  @Override
  public  void fromApp(Message message, SessionID sessionId) throws FieldNotFound, IncorrectTagValue,
          UnsupportedMessageType {
    if (message instanceof NewOrderSingle) {
      NewOrderSingle newOrderSingle = ((NewOrderSingle) message);
      ExecutionReport executionReport = new ExecutionReport();
      String clOrdID = newOrderSingle.getClOrdID().getValue();
      executionReport.set(new ClOrdID(clOrdID));
      executionReport.set(new ExecID(&quot;98765&quot;));
      executionReport.set(new OrderID(&quot;99999&quot;));
      executionReport.set(newOrderSingle.getSide());
      executionReport.set(new OrdStatus(OrdStatus.NEW));
      executionReport.set(new CumQty(0));
      executionReport.set(new ExecType(ExecType.NEW));
      executionReport.set(new LeavesQty(newOrderSingle.getOrderQty().getValue()));
      try {
        Session.sendToTarget(executionReport, sessionId);
      } catch (SessionNotFound e) {
        throw new RuntimeException(e);
      }
    }
  }

}

</code></pre>

<p>Este es el <code>Application</code> del servidor de ejemplo. En el método <code>fromAdmin</code> (donde se reciben los mensajes administrativos), validamos el <code>Login</code>, si no coincide el usuario y password, lanzamos la excepcion <code>RejectLogin</code>.</p>

<p><strong>Nota:</strong> en este esquema sencillo, el password viaja como texto plano: Las conexiones de FIX tienen que segurizarse por medio de algún esquema como SSL, utilizar una VPN, o similar.</p>

<p>En el metodo <code>fromApp</code> recibimos el <code>NewOrderSingle</code> y creamos un mensaje de <code>ExecutionReport</code> y le asignamos varios campos (en este ejemplo, solo los obligatorios). En el campo <code>ClOrdID</code>, copiamos el dato recibido por el <code>NewOrderSingle</code>, para que el cliente pueda detectar a que <code>ExecutionReport</code> corresponde. Y finalmente enviamos el mensaje.</p>

<p>``` java ExampleFixTest.java</p>

<p>package com.tenpines.ejemplofix;</p>

<p>import java.util.Date;</p>

<p>import org.junit.Assert;
import org.junit.Test;</p>

<p>import com.tenpines.ejemplofix.ExampleClientApplication;
import com.tenpines.ejemplofix.ExampleServerApplication;</p>

<p>import quickfix.Application;
import quickfix.ConfigError;
import quickfix.DefaultMessageFactory;
import quickfix.MemoryStoreFactory;
import quickfix.ScreenLogFactory;
import quickfix.SessionSettings;
import quickfix.SocketAcceptor;
import quickfix.SocketInitiator;
import quickfix.field.ClOrdID;
import quickfix.field.OrdType;
import quickfix.field.OrderQty;
import quickfix.field.Side;
import quickfix.field.TransactTime;
import quickfix.fix50.NewOrderSingle;</p>

<p>public class ExampleFixTest {</p>

<p>@Test
  public  void test() throws Exception {
    iniciarServidor();
    String password = &ldquo;password&rdquo;;
    String usuario = &ldquo;usuario&rdquo;;
    NewOrderSingle newOrder = new NewOrderSingle(new ClOrdID(&ldquo;12345&rdquo;), new Side(Side.BUY),
        new TransactTime(new Date()), new OrdType(OrdType.MARKET));
    newOrder.set(new OrderQty(1000));
    ExampleClientApplication application = new ExampleClientApplication(newOrder, usuario, password);
    iniciarCliente(application);
    Thread.sleep(5000L); // 5 segundos
    Assert.assertTrue(application.estaLogueado());
    Assert.assertTrue(application.seEjecutoOrdenCorrectamente());
  }</p>

<p>private  void iniciarCliente(Application application) throws ConfigError {
    SessionSettings settings = new SessionSettings(this.getClass().getResourceAsStream(&ldquo;cliente.cfg&rdquo;));
    SocketInitiator socketInitiator = new SocketInitiator(application, new MemoryStoreFactory(), settings,
            new ScreenLogFactory(), new DefaultMessageFactory());
    socketInitiator.start();
  }</p>

<p>private  void iniciarServidor() throws ConfigError {
    SessionSettings settings = new SessionSettings(this.getClass().getResourceAsStream(&ldquo;servidor.cfg&rdquo;));
    ExampleServerApplication application = new ExampleServerApplication();
    SocketAcceptor acceptor = new SocketAcceptor(application, new MemoryStoreFactory(), settings,
            new ScreenLogFactory(), new DefaultMessageFactory());
    acceptor.start();
  }
}</p>

<pre><code>
En este test inicializamos el cliente y el servidor, y vemos que efectivamente el cliente se loguea contra el servidor, envia la orden, y recibe la respuesta. Notese que el cliente y el servidor se construyen de maneras distintas pero similares: el primero con un `SocketIniciator` y el segundo con un `SocketAcceptor`. En el constructor de cada uno de ellos se pasan objetos que permiten parametrizar el comportamiento del motor de **QuickFIX/J**, definiendo el esquema de logging, como se guardan los mensajes, y cual es el Factory de los mensajes (que depende de la versión del protocolo de **FIX**, pero `DefaultMessageFactory` sirve para cualquier versión).

Hay que tener cuidado al hacer tests integrales con **QuickFIX/J**, ya que como el `Application` corre en un thread aparte, instanciado por **QuickFIX/J**, perdemos el control de la ejecución y necesitamos algún tipo de espera o sincronismo para asegurarnos de que cumplieron las acciones deseadas (en este caso, que se loguee el cliente contra el servidor y se envien entre ellos los mensajes `NewOrderSingle` y `ExecutionReport`). Por esto hay en el test un `Thread.sleep` con 5 segundos, si este fuera un test real, lo correcto sería utilizar polling con timeout, no `Thread.sleep` ya que es un método obviamente lento.

``` linux-config cliente.cfg

[default]
ConnectionType=initiator
StartTime=00:00:00
EndTime=00:00:00
HeartBtInt=300

[session]
BeginString=FIXT.1.1
DefaultApplVerID=FIX.5.0
SocketConnectHost=localhost
SocketConnectPort=9876
SenderCompID=CLIENTE
TargetCompID=SERVIDOR

</code></pre>

<p>``` linux-config servidor.cfg</p>

<p>[default]
ConnectionType=acceptor</p>

<p>StartTime=00:00:00
EndTime=00:00:00</p>

<p>HeartBtInt=300
RejectInvalidMessage=N</p>

<p>[session]
BeginString=FIXT.1.1
DefaultApplVerID=FIX.5.0
SocketAcceptPort=9876
SenderCompID=SERVIDOR
TargetCompID=CLIENTE</p>

<pre><code>
`ConnectionType` identifica el tipo de conexión, es decir, si es servidor o cliente. `StartTime` y `EndTime` indican el inicio y fin de la sesión y está relacionado al tiempo de apertura y cierre de los mercados. `BeginString` indica la versión del protocolo de transporte de **FIX**, y `DefaultApplVerID` indica la versión del protocolo (las versiones anterior a la 5, no tienen un protocolo de transporte especifico diferenciado de la versión de **FIX** en sí, y se definen únicamente por el `BeginString` indicando el protocolo de **FIX**).

`SenderCompID` y `TargetCompID` son identificadores de los interlocutores de la sesión, y están invertidos en el Cliente y el Servidor. En **FIX**, la sesión es algo que se considera que va más allá de la conexión dada en un momento, si la conexión se cae y después se vuelve a conectar, la sesión sigue siendo la misma, y de hecho se reenvían los mensajes pendientes al momento de caerse la sesión (en **QuickFIX/J** para que esto funcione hay que instanciar el `SocketAcceptor/Initiator` con el `FileStoreFactory`, no el `MemoryStoreFactory`, el cual guarda los mensajes en un archivo para poder reenviarlos). Justamente porque la sesión es algo global, el `SessionID` de **QuickFIX/J** está definido básicamente por tres valores: `SenderCompID`, `TargetCompID` y `BeginString`.

## Cuestiones a considerar de QuickFIX/J

**QuickFIX/J** utiliza &quot;diccionarios&quot; que definen los mensajes de **FIX**:

- Los tipos de mensajes y su código identificatorio
- Los campos que contiene cada mensaje, su tipo, valores válidos
- Los repeating groups (cual es el encabezado del grupo y los campos de los elementos del repeating group)

Cada diccionario es un XML que se puede editar. Si abrimos los fuentes de **QuickFIX/J** veremos que tiene un diccionario de datos por cada versión del protocolo **FIX**, y utiliza generación de código en el build para crear todas las clases que representan cada mensaje y cada campo (ya que en **QuickFIX/J**, cada campo es una clase). Si queremos, podemos modificar este XML y configurar **QuickFIX/J** para que utilice nuestro XML, esto es necesario si utilizamos extensiones del protocolo que agreguen nuevos campos.

Justamente por ser estas clases autogeneradas, tienen ciertos aspectos contra-intutivos:

Cada campo está representado por una clase. El campo `OrderQty`, que representa la cantidad a comerciar en una órden y es un número, por ejemplo, está representado por la clase `OrderQty`, y una instancia de `OrderQty` tiene métodos como `getValue` para obtener el valor del campo y `getField` para obtener el número de campo en el protocolo.

En las clases que representan los mensajes, no existen métodos `setCAMPO(tipoDeDato)`, sino unicamente overloads del metodo set que reciben la clase que representa el tipo de dato. Por eso, para setear por ejemplo el campo `OrderQty`, hay que hacer cosas como `newOrder.set(new OrderQty(1000))`. Y los métodos get, si bien están definidos, devuelven el valor envuelto en la clase que representa su campo.

Los **Repeating Groups** también están representados por una clase, y la clase se llama igual que el campo del encabezado. Por ejemplo, en el mensaje `SecurityList`, que contiene una lista de instrumentos financieros, hay un repeating group de instrumentos, y para extraerlos, hay que hacer lo siguiente:

``` java

quickfix.fix50.SecurityList.NoRelatedSym noRelatedSym = new quickfix.fix50.SecurityList.NoRelatedSym();
message.getGroup(indiceDeGrupo + 1, noRelatedSym); // +1 porque el primer grupo tiene indice 1, no 0.
//ahora noRelatedSym tiene los datos del grupo

</code></pre>

<p>Esto es confuso porque <code>NoRelatedSym</code> es en realidad el nombre del campo que tiene la cantidad de simbolos relacionados (&ldquo;No&rdquo; en &ldquo;NoRelatedSym&rdquo; es una abreviación de &ldquo;número&rdquo;), y no del <strong>Repeating Group</strong> en sí, esto es una consecuencia de la generación de código automática de <strong>QuickFix/J</strong>. Para añadir confusión, hay multiples clases llamadas <code>NoRelatedSym</code>, cada una de ellas representando un <strong>Repeating Group</strong> distinto dentro de cada mensaje. Por eso estas clases son internas al mensaje (como se puede ver en el ejemplo, esta clase <code>NoRelatedSym</code> es interna a la clase <code>SecurityList</code>).</p>

<h3 id="recursos-útiles">Recursos útiles</h3>

<ul>
<li><a href="http://www.fixprotocol.org:">http://www.fixprotocol.org:</a> Donde se puede conseguir la especificación del protocolo en todas sus versiones. Dentro de este sitio se encuentra <a href="http://www.fixprotocol.org/FIXimate3.0/">FIXimate</a>, herramienta que permite consultar mensajes o campos por su código, esencial para entender mensajes de errores y logs de mensajes.</li>
<li><a href="http://www.quickfixj.org/:">http://www.quickfixj.org/:</a> Sitio web de QuickFIX/J, con la documentación de la librería.</li>
</ul>

  			</section>

  			<footer class="post-footer">
  				<div class="post-tags">
            
  				</div>
  				<div class="post-share">
  					<a class="icon-twitter" href="https://twitter.com/share?text=protocolo%20fix%3a%20aspectos%20b%c3%a1sicos%20y%20utilizaci%c3%b3n%20en%20java%20mediante%20la%20librer%c3%ada%20quickfix%2fj&url=https%3a%2f%2fegutter.github.io%2f2011%2f11%2f21%2fprotocolo-fix-aspectos-basicos-y-utilizacion-en-java-mediante-la-librera-quickfixj%2f" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
  						<span>Twitter</span>
  					</a>
  					<a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fegutter.github.io%2f2011%2f11%2f21%2fprotocolo-fix-aspectos-basicos-y-utilizacion-en-java-mediante-la-librera-quickfixj%2f" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
  						<span>Facebook</span>
  					</a>
  					<a class="icon-gplus" href="https://plus.google.com/share?url=https%3a%2f%2fegutter.github.io%2f2011%2f11%2f21%2fprotocolo-fix-aspectos-basicos-y-utilizacion-en-java-mediante-la-librera-quickfixj%2f" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
  						<span>Google+</span>
  					</a>
  				</div>
  			</footer>

  			<aside class="post-comments">
    
    
    <div id="disqus_thread"></div>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    
    
</aside>


			</div>

			<nav class="post-nav">
				
					<a class="post-nav-item post-nav-next" href="https://egutter.github.io/2012/01/12/about-names-when-designing-with-objects/">
						<section class="post-nav-teaser">
							<span class="post-nav-icon"><i class="icon-arrow-left"></i></span>
							<span class="post-nav-info">
								<h4 class="post-nav-title">About names when designing with objects</h4>
								<p class="post-nav-excerpt">&hellip;</p>
							</span>
						</section>
					</a>
				
				
					<a class="post-nav-item post-nav-prev" href="https://egutter.github.io/2011/09/02/agile-slc-we-were-there/">
						<section class="post-nav-teaser">
							<span class="post-nav-icon"><i class="icon-arrow-right"></i></span>
							<span class="post-nav-info">
								<h4 class="post-nav-title">agile 2011 slc we were there</h4>
								<p class="post-nav-excerpt">&hellip;</p>
							</span>
						</section>
					</a>
				
				<div class="clear"></div>
			</nav>

		</div>
	</article>
</main>

				<div id="body-class" style="display: none;"></div>
				<footer id="footer">
					<section class="credits">
						<span class="credits-theme">Theme <a href="https://github.com/zenithar/hugo-theme-bleak" target="_blank" rel="nofollow">Bleak</a> by <a href="http://zutrinken.com" target="_blank" rel="nofollow">zutrinken</a></span>
						<span class="credits-software">Published with <a href="http://gohugo.io" target="_blank" rel="nofollow">Hugo</a></span>
					</section>
				</footer>
				
				
<div id="tocMenu" data-target="toc">
    <div class="menu-header">
        <span class="menu-label">Menu</span>
        <a class="menu-close" data-action="toc" data-target="toc"></a>
    </div>
    <div id="toc" class="menu-list">
        <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#introducción">Introducción</a></li>
<li><a href="#diferentes-versiones-del-protocolo-fix">Diferentes versiones del protocolo FIX</a></li>
<li><a href="#cómo-es-el-formato-fix">Cómo es el formato FIX</a></li>
<li><a href="#quickfix-j">QuickFIX/J</a></li>
<li><a href="#ejemplos-de-cliente-y-servidor-en-quickfix-j">Ejemplos de Cliente y Servidor en QuickFIX/J</a>
<ul>
<li><a href="#recursos-útiles">Recursos útiles</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
    </div>
</div>


				<div class="overlay"></div>
			</div>
		</section>

    <script>
      (function(c,f){asyncLoader=function(i,h){i.foreach(function(k,j){e(j,d(j),h)});if(typeof h.callback=="function"){var g=setInterval(function(){if(f.readyState==="complete"){clearInterval(g);h.callback()}},10)}};var d=function(g){var h=g.split(".");return h[h.length-1]},e=function(h,i,g){switch(i){case"js":a(h,g);break;case"css":b(h);break;default:break}},a=function(i,h){var g=document.createElement("script");g.type="text/javascript";g.async=true;g.src=i;document.getElementsByTagName("head")[0].appendChild(g)},b=function(g){var h=document.createElement("link");h.type="text/css";h.rel="stylesheet";h.href=g;document.getElementsByTagName("head")[0].appendChild(h)};Array.prototype.foreach=function(h){for(var g=0;g<this.length;g++){h(g,this[g])}}})(this,document);

      asyncLoader([
				"/js/dependencies.js",
				"/css/dependencies.css"
      ],{
        callback:function(){
					asyncLoader([
						"/css/style.css",
						"/js/script.js"
					], {
						callback: function() {
							$('body').fadeIn( 800 );
						}
					});
        }
      });

</script>



</body>
</html>

